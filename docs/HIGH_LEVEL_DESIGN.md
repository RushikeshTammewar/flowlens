# FlowLens — High Level Design

> Last updated: February 2026

---

## Table of Contents

1. [System Overview](#1-system-overview)
2. [Architecture](#2-architecture)
3. [Site Context Intelligence](#3-site-context-intelligence)
4. [Component Design](#4-component-design)
5. [Data Flow](#5-data-flow)
6. [Tech Stack](#6-tech-stack)
7. [UX Architecture](#7-ux-architecture)
8. [Deployment Architecture](#8-deployment-architecture)
9. [Security Model](#9-security-model)
10. [Scalability Strategy](#10-scalability-strategy)

---

## 1. System Overview

FlowLens is a multi-tenant SaaS platform with five primary subsystems:

1. **Dashboard** — The user-facing web application (Notion-style UX)
2. **API Server** — Backend service layer handling all business logic
3. **Agent Engine** — Autonomous AI browser agent that crawls websites
4. **Analytics Engine** — Diff, trend, regression, and health score computation
5. **Notification System** — Daily briefings, instant alerts, integrations

The system operates on a **crawl → analyze → report** cycle that runs daily for every monitored site. Each cycle produces structured data that feeds into a persistent **Site Context** — a living knowledge base about each client's website that grows richer over time.

### Design Principles

- **Context-first:** Every decision the system makes is informed by the site's history and stored context.
- **Human-readable outputs:** Reports and briefings read like they were written by a colleague, not generated by a tool.
- **Progressive depth:** Surface = simple health score. One click deeper = trends. Another click = raw evidence.
- **Minimal configuration:** The system should work with just a URL. Every other setting is optional.
- **Idempotent crawls:** Running the same crawl twice on an unchanged site should produce identical results.

---

## 2. Architecture

### System Context Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        EXTERNAL SYSTEMS                         │
│                                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌───────────────┐  │
│  │  Client   │  │  Slack   │  │  Jira /  │  │  CI/CD        │  │
│  │  Website  │  │  Teams   │  │  Linear  │  │  (GitHub etc) │  │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └──────┬────────┘  │
│       │              │             │               │            │
└───────┼──────────────┼─────────────┼───────────────┼────────────┘
        │              │             │               │
        ▼              ▲             ▲               │
┌───────────────────────────────────────────────────────────────┐
│                       FLOWLENSE PLATFORM                       │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   PRESENTATION LAYER                     │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │   │
│  │  │  Dashboard   │  │  Landing     │  │  Public       │  │   │
│  │  │  (Next.js)   │  │  Page        │  │  Report Page  │  │   │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │   │
│  └─────────┼─────────────────┼─────────────────┼───────────┘   │
│            │                 │                 │                │
│            ▼                 ▼                 ▼                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    API LAYER (FastAPI)                    │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐  │   │
│  │  │ Projects │  │ Crawls   │  │ Bugs     │  │ Trends │  │   │
│  │  │ API      │  │ API      │  │ API      │  │ API    │  │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └────────┘  │   │
│  └─────────────────────────┬───────────────────────────────┘   │
│                            │                                    │
│            ┌───────────────┼───────────────┐                   │
│            ▼               ▼               ▼                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐     │
│  │   AGENT      │  │  ANALYTICS   │  │  NOTIFICATION    │     │
│  │   ENGINE     │  │  ENGINE      │  │  ENGINE          │     │
│  │              │  │              │  │                   │     │
│  │  Planner     │  │  Diff Engine │  │  Daily Briefing  │     │
│  │  Navigator   │  │  Trend Calc  │  │  Instant Alerts  │     │
│  │  Executor    │  │  Regression  │  │  Weekly Summary  │     │
│  │  Observer    │  │  Health Score│  │  Slack/Email/PD   │     │
│  │  Detectors   │  │              │  │                   │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────────┘     │
│         │                 │                  │                  │
│         ▼                 ▼                  ▼                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    STORAGE LAYER                         │   │
│  │  ┌──────────┐  ┌──────────────┐  ┌──────┐  ┌────────┐  │   │
│  │  │PostgreSQL│  │ TimescaleDB  │  │  S3  │  │ Redis  │  │   │
│  │  │(core)    │  │ (time-series)│  │(media)│  │(cache) │  │   │
│  │  └──────────┘  └──────────────┘  └──────┘  └────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  SITE CONTEXT STORE                       │   │
│  │  Per-client persistent intelligence about their website   │   │
│  │  Site graph, flow definitions, page fingerprints,         │   │
│  │  performance baselines, bug history, content snapshots    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Component Interaction Flow

```
                    ┌─────────────┐
                    │  Scheduler  │
                    │  (cron)     │
                    └──────┬──────┘
                           │ triggers daily
                           ▼
                    ┌─────────────┐
                    │  Orchestrator│ ← also triggered by deploy webhooks
                    └──────┬──────┘
                           │
              ┌────────────┼────────────┐
              ▼            ▼            ▼
        ┌───────────┐ ┌────────┐ ┌──────────┐
        │ Discovery │ │ Agent  │ │ Agent    │    (parallel per viewport)
        │ Crawl     │ │ Desktop│ │ Mobile   │
        └─────┬─────┘ └───┬────┘ └────┬─────┘
              │            │           │
              ▼            ▼           ▼
        ┌─────────────────────────────────────┐
        │         RAW CRAWL RESULTS           │
        │  bugs[], perf_metrics[], screenshots│
        └──────────────┬──────────────────────┘
                       │
                       ▼
        ┌─────────────────────────────────────┐
        │         ANALYTICS PIPELINE          │
        │                                     │
        │  1. Bug fingerprinting + dedup      │
        │  2. Diff with previous crawl        │
        │  3. Update bug lifecycles           │
        │  4. Compute perf trends             │
        │  5. Detect regressions              │
        │  6. Calculate health score          │
        │  7. Update Site Context             │
        └──────────────┬──────────────────────┘
                       │
                       ▼
        ┌─────────────────────────────────────┐
        │         NOTIFICATION DISPATCH       │
        │                                     │
        │  P0 bug? → Instant alert (Slack/PD) │
        │  Morning? → Daily briefing (email)  │
        │  Sunday?  → Weekly summary          │
        └─────────────────────────────────────┘
```

---

## 3. Site Context Intelligence

This is FlowLens's most important architectural concept. For every client website, we maintain a persistent, evolving **Site Context** — a knowledge base that makes the agent smarter over time.

### What is Site Context?

Site Context is the sum of everything FlowLens knows about a client's website. It's built incrementally across crawls and never thrown away. It includes:

```
SITE CONTEXT for myapp.com
│
├── Site Graph (structural map)
│   ├── Pages: [/home, /login, /dashboard, /settings, /checkout, ...]
│   ├── Edges: [/home → /login, /login → /dashboard, ...]
│   ├── Page types: {/login: "auth", /checkout: "transaction", ...}
│   └── Last updated: Crawl #144
│
├── Flow Registry (discovered user journeys)
│   ├── Flow "Checkout": /home → /products → /cart → /checkout
│   ├── Flow "Login": /home → /login → /dashboard
│   ├── Flow "Signup": /home → /signup → /verify → /onboarding
│   ├── Flow priority: checkout > login > signup > browse
│   └── Auth required: {checkout: yes, login: yes, signup: no}
│
├── Page Fingerprints (what each page looks like)
│   ├── /home: {elements: 47, forms: 0, ctas: 3, images: 12, hash: "a3f2..."}
│   ├── /checkout: {elements: 23, forms: 2, ctas: 1, images: 3, hash: "b7c1..."}
│   └── Used to detect: page redesigns, content changes, element additions/removals
│
├── Performance Baselines (what's "normal" for this site)
│   ├── /home: avg_load=1.8s, p95=2.4s, stddev=0.3s (based on last 30 crawls)
│   ├── /checkout: avg_load=1.2s, p95=1.6s, stddev=0.2s
│   └── Used for: regression detection (alert only if > 2 stddev from baseline)
│
├── Bug History (every bug ever found)
│   ├── Active bugs: [{id, fingerprint, first_seen, last_seen, severity, ...}]
│   ├── Fixed bugs: [{id, fingerprint, first_seen, fixed_at, ...}]
│   ├── Snoozed bugs: [{id, reason, snooze_until, ...}]
│   └── False positives: [{id, fingerprint, marked_by, ...}]
│
├── Content Snapshots (DOM state per page per crawl)
│   ├── Used for: visual diff between crawls
│   └── Retention: last 30 snapshots per page (configurable)
│
└── Deploy Events (correlate changes with deploys)
    ├── [{timestamp, commit_sha, source: "github_webhook", ...}]
    └── Used for: "This regression appeared after deploy abc123"
```

### Why Site Context Matters

1. **Smarter crawls:** The agent doesn't rediscover flows every time. It re-uses known flows and only re-plans when the site structure changes.
2. **Accurate regression detection:** Performance baselines are per-page and per-site. We know what's "normal" for YOUR site, not some generic threshold.
3. **Bug deduplication:** The fingerprint system ensures we don't report the same bug as "new" every day.
4. **False positive reduction:** When a user marks something as a false positive, that fingerprint is remembered forever.
5. **Retention moat:** The longer you use FlowLens, the smarter it gets. Switching to a competitor means losing all that accumulated intelligence.

### Site Context Storage Design

Site Context is not a single table — it's distributed across the storage layer:

| Context component | Storage | Why |
|---|---|---|
| Site graph + flows | PostgreSQL (JSONB) | Structured, queryable, versioned |
| Page fingerprints | PostgreSQL | Small per-page, need exact matching |
| Performance baselines | TimescaleDB | Time-series aggregation queries |
| Bug history | PostgreSQL | Relational (joins with crawls, pages) |
| Content snapshots (DOM) | S3 | Large blobs, accessed infrequently |
| Screenshots | S3 | Binary data, CDN-served for dashboard |
| Deploy events | PostgreSQL | Relational (join with crawls for correlation) |

---

## 4. Component Design

### 4.1 Agent Engine

The agent is the core intelligence. It runs as an isolated Docker container with a Playwright browser instance.

**Agent Hierarchy:**

```
┌──────────────────────────────────────────────────┐
│                    PLANNER                         │
│  Input: Site Context (graph, flows, baselines)     │
│  Output: Ordered list of flows to test             │
│  Runs: Once per crawl                              │
│  LLM: Yes (only if site structure changed)         │
│  Decision: "Which flows to test and in what order?" │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────┐
│                   NAVIGATOR                        │
│  Input: Current page screenshot + DOM + context    │
│  Output: Next action to take                       │
│  Runs: Per page visit                              │
│  LLM: Yes (vision model)                           │
│  Decision: "What should I do on this page?"        │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────┐
│                   EXECUTOR                         │
│  Input: Action intent from Navigator               │
│  Output: Playwright command execution              │
│  Runs: Per action                                  │
│  LLM: Fallback only (for ambiguous selectors)      │
│  Decision: "How to translate intent to DOM action?" │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────┐
│                   OBSERVER                         │
│  Input: Page state after action                    │
│  Output: Bug findings + performance metrics        │
│  Runs: After every action                          │
│  LLM: Only for visual bug detection                │
│  Decision: "Is something wrong with this page?"    │
└──────────────────────────────────────────────────┘
```

**Key design decisions for the agent:**

- **LLM calls are minimized.** The Planner uses stored context (no LLM needed if site hasn't changed). The Navigator uses LLM vision per page. The Executor is mostly deterministic. The Observer runs heuristic checks first, only calling LLM for visual anomaly detection.
- **Each agent run is stateless within the container.** All persistent state lives in the database (Site Context). The container can be killed and restarted without data loss.
- **Viewport parallelism.** Desktop, tablet, and mobile crawls run in parallel containers, sharing the same flow plan.

### 4.2 Analytics Engine

The analytics engine runs as a post-crawl pipeline. It takes raw crawl results and produces actionable intelligence.

**Pipeline stages:**

```
RAW CRAWL RESULTS
    │
    ├── 1. BUG FINGERPRINTER
    │       Generate fingerprint for each bug (hash of page + type + location)
    │       Match against existing bugs in Site Context
    │       Result: new_bugs[], existing_bugs[], fixed_bugs[]
    │
    ├── 2. DIFF ENGINE
    │       Compare this crawl's findings with previous crawl
    │       Detect: new pages, removed pages, changed flows
    │       Detect: new bugs, resolved bugs, persistent bugs
    │       Result: crawl_diff object
    │
    ├── 3. PERFORMANCE TRACKER
    │       Store per-page metrics in TimescaleDB
    │       Compare against performance baseline (rolling 30-day avg)
    │       Flag significant deviations (> 2 std deviations)
    │       Result: perf_changes[]
    │
    ├── 4. REGRESSION DETECTOR
    │       Correlate new bugs + perf changes with deploy events
    │       Apply statistical significance test (not just any change)
    │       Result: regressions[] with confidence scores
    │
    ├── 5. HEALTH SCORE CALCULATOR
    │       Compute composite score (0-100)
    │       Store in TimescaleDB for trending
    │       Compare with yesterday's score
    │       Result: health_score, health_delta
    │
    └── 6. SITE CONTEXT UPDATER
            Update site graph if structure changed
            Update flow registry if new flows discovered
            Update page fingerprints
            Update performance baselines (rolling window)
            Result: updated Site Context
```

### 4.3 Notification Engine

Responsible for turning analytics outputs into human-readable communications.

**Three notification types:**

| Type | Trigger | Channel | Content |
|---|---|---|---|
| Instant alert | P0 bug detected | Slack + email + PagerDuty | Critical bug details, impact estimate, evidence links |
| Daily briefing | Cron (9 AM user timezone) | Email + Slack | Full summary: new/fixed/persistent bugs, perf changes, health score |
| Weekly summary | Cron (Monday 9 AM) | Email | Trend report: health trajectory, top persistent bugs, performance trends |

**Briefing generation:**
The daily briefing is NOT a template with variables filled in. It's generated by an LLM that receives structured data (crawl diff, bugs, perf changes, health score) and writes a natural, conversational summary. The tone is warm, friendly, and direct — like a colleague's Slack message, not an automated report.

---

## 5. Data Flow

### 5.1 Daily Crawl Flow

```
Time: 2:00 AM (configurable per project)

1. Scheduler triggers crawl job for project "myapp.com"
2. Orchestrator loads Site Context for myapp.com
3. Planner creates flow execution plan
   - If site graph unchanged since last crawl: reuse existing flows
   - If site graph changed: re-plan using LLM
4. Orchestrator spawns agent containers (1 per viewport)
   - Desktop: 1920x1080
   - Tablet: 768x1024
   - Mobile: 375x812
5. Each agent executes flows:
   - Navigate to page → screenshot → DOM extract → detect bugs → record metrics
   - Repeat for each step in each flow
6. Agents write results to staging tables:
   - raw_bugs (unfingerprinted)
   - raw_metrics (unprocessed)
   - raw_screenshots → S3
7. Analytics pipeline runs:
   - Fingerprint bugs → deduplicate → update bug lifecycles
   - Compute diffs with previous crawl
   - Track performance trends
   - Detect regressions
   - Calculate health score
   - Update Site Context
8. Results written to production tables
9. If P0 bug found: Instant alert dispatched immediately (step 6, before analytics)
10. Crawl marked complete. Results available in dashboard.

Time: 9:00 AM (user timezone)

11. Notification worker generates daily briefing
12. Briefing sent via configured channels (email, Slack)
```

### 5.2 Deploy-Triggered Crawl Flow

```
1. User's CI/CD sends POST to /api/webhooks/deploy
   Body: { commit_sha, branch, environment, timestamp }
2. Deploy event stored in Site Context
3. Orchestrator triggers immediate crawl (same as daily, but labeled "deploy-triggered")
4. Crawl completes in 15-30 minutes
5. Regression detector specifically checks for changes correlated with this deploy
6. If regressions found: alert includes deploy correlation
   "This regression appeared 8 minutes after deploy abc123"
7. Results appear in dashboard with deploy marker on timeline
```

### 5.3 Free Scan Flow

```
1. Anonymous user pastes URL on flowlens.com
2. API creates a temporary project (no auth required)
3. Lightweight crawl runs: top 20 pages, desktop + mobile only
4. Basic detectors only (broken links, JS errors, responsive issues, perf)
5. Report generated on a public URL (e.g., flowlens.com/report/abc123)
6. User sees: Health Score + Top 5 Bugs + Quick Wins
7. CTA: "Want this every morning? Start free trial."
8. If user signs up: temporary project converts to permanent project
   - Free scan results become the first crawl in their history
```

---

## 6. Tech Stack

### 6.1 Frontend

| Component | Technology | Rationale |
|---|---|---|
| Framework | Next.js 14 (App Router) | SSR for landing/SEO, client-side for dashboard interactivity |
| Styling | Tailwind CSS + custom design system | Utility-first, rapid iteration, consistent spacing/color |
| Component library | Radix UI primitives + custom components | Accessible, unstyled primitives. NOT shadcn/ui — we build our own design language. |
| Charts | Recharts | Composable, React-native charting for time-series trends |
| Flow map visualization | React Flow | Interactive node/edge graph for site map |
| State management | TanStack Query (React Query) | Server state caching, automatic refetching |
| Real-time | Server-Sent Events (SSE) | Crawl live view — simpler than WebSockets for unidirectional updates |
| Animation | Framer Motion | Page transitions, chart animations, micro-interactions |
| Icons | Lucide React | Clean, consistent icon set |

**UX Design System — "Notion-inspired, but ours"**

The dashboard should feel warm, approachable, and calm. Not a wall of metrics — a place you actually want to visit.

Design tokens:
- **Typography:** Inter for UI, JetBrains Mono for code/metrics
- **Color palette:** Warm neutrals (not cold grays). Soft backgrounds. Color used sparingly and meaningfully.
  - Background: `#FAFAF9` (warm off-white)
  - Surface: `#FFFFFF`
  - Text primary: `#1A1A1A`
  - Text secondary: `#6B6B6B`
  - Accent: `#2563EB` (blue — trust, reliability)
  - Success: `#16A34A`
  - Warning: `#EAB308`
  - Critical: `#DC2626`
  - Borders: `#E5E5E3` (warm, subtle)
- **Spacing:** 4px base unit. Generous whitespace. Content breathes.
- **Corners:** 8px border-radius (friendly, not sharp)
- **Shadows:** Minimal. Subtle elevation only where needed.
- **Motion:** Subtle, purposeful. 200ms ease-out transitions. No bouncing.
- **Density:** Low density by default. Information revealed progressively.

Key UX patterns:
- **Card-based layout:** Each piece of information lives in a card. Cards are scannable.
- **Progressive disclosure:** Overview first. Click to expand. Click again for raw data.
- **Inline actions:** "Create Jira ticket" button right on the bug card. No modal workflows.
- **Contextual help:** Subtle tooltips explaining what metrics mean. Never assume the user knows.
- **Empty states:** Friendly, helpful. "No bugs found today. Your site is looking healthy."
- **Loading states:** Skeleton screens, not spinners. Content feels like it's there before it loads.

Page-by-page UX:

**Dashboard Home:**
```
┌────────────────────────────────────────────────────┐
│                                                      │
│  Good morning, Rushikesh.                            │
│                                                      │
│  ┌─────────────────┐  ┌──────────────────────────┐  │
│  │  HEALTH SCORE   │  │  TODAY'S CHANGES          │  │
│  │                 │  │                            │  │
│  │     78/100      │  │  2 new bugs               │  │
│  │    ↑3 today     │  │  3 bugs fixed             │  │
│  │                 │  │  1 performance alert       │  │
│  │  [30-day chart] │  │                            │  │
│  └─────────────────┘  └──────────────────────────┘  │
│                                                      │
│  ┌──────────────────────────────────────────────┐   │
│  │  ACTIVE BUGS                                  │   │
│  │                                                │   │
│  │  ● P1  Checkout btn unresponsive   Mobile  2d  │   │
│  │  ● P2  Hero image 404            Desktop  new  │   │
│  │  ● P2  Form validation missing    Tablet   5d  │   │
│  │                                                │   │
│  │  View all 7 active bugs →                      │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
│  ┌──────────────────────────────────────────────┐   │
│  │  PERFORMANCE SNAPSHOT                         │   │
│  │                                                │   │
│  │  /checkout   2.8s  ↑1.6s  ▓▓▓▓▓▓▓▓░░        │   │
│  │  /homepage   1.9s  ↓0.4s  ▓▓▓▓░░░░░░        │   │
│  │  /search     0.8s    —    ▓▓░░░░░░░░        │   │
│  │                                                │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
└────────────────────────────────────────────────────┘
```

### 6.2 Backend

| Component | Technology | Rationale |
|---|---|---|
| API framework | FastAPI (Python) | Async, fast, auto-docs, strong typing with Pydantic |
| ORM | SQLAlchemy 2.0 + Alembic | Mature, async support, migration management |
| Task queue | Temporal.io | Complex workflow orchestration with retries, timeouts, visibility |
| Background workers | Temporal workers (Python) | Same language as agent, shared models |
| Auth | Clerk | Fast integration, SSO, webhook-based user sync |
| Email | SendGrid | Reliable transactional email for daily briefings |
| API documentation | Auto-generated from FastAPI + Pydantic | OpenAPI/Swagger out of the box |

**API Design Principles:**
- RESTful with consistent naming (`/api/v1/projects/{id}/crawls`)
- Pagination on all list endpoints (cursor-based, not offset)
- Consistent error format: `{ error: { code, message, details } }`
- Rate limiting: 100 req/min for standard, 1000 req/min for premium
- Versioned: `/api/v1/...` from day one

### 6.3 Agent

| Component | Technology | Rationale |
|---|---|---|
| Browser automation | Playwright (Python) | Most reliable headless browser. Supports Chromium, Firefox, WebKit. |
| LLM client | Anthropic Claude API (primary) | Vision capability for screenshot analysis, strong reasoning |
| LLM fallback | OpenAI GPT-4o | Secondary model for redundancy |
| Accessibility testing | axe-core (via Playwright injection) | Industry-standard a11y rules engine |
| Container runtime | Docker | Isolated, reproducible, scalable |
| Screenshot processing | Pillow (Python) | Annotation, cropping, comparison |

### 6.4 Storage

| Store | Technology | What it holds | Why this choice |
|---|---|---|---|
| Primary DB | PostgreSQL 16 | Projects, users, crawls, bugs, site context, flows | Reliable, JSONB for flexible schemas, strong ecosystem |
| Time-series DB | TimescaleDB (PG extension) | Perf metrics, health scores, per-page stats over time | Runs on same PG instance, efficient time-range queries, automatic partitioning |
| Object storage | AWS S3 | Screenshots, recordings, DOM snapshots, HAR files | Cheap, durable, CDN-friendly |
| Cache + queue | Redis 7 | Job queues, real-time crawl status, session cache, rate limiting | Fast, pub/sub for SSE, BullMQ-compatible |

**Why TimescaleDB instead of a separate time-series DB (InfluxDB, Prometheus)?**
- Runs as a PostgreSQL extension — no new infrastructure to manage
- Can JOIN time-series data with relational data (bugs, projects) in a single query
- Hypertable partitioning gives excellent query performance for time-range access patterns
- Compression gives 90-95% storage reduction on historical data

### 6.5 Infrastructure

| Component | MVP | At scale |
|---|---|---|
| Hosting | Railway / Fly.io | AWS ECS (Fargate) |
| Container orchestration | Docker Compose | AWS ECS / Kubernetes |
| CDN | Cloudflare | Cloudflare |
| DNS | Cloudflare | Cloudflare |
| Monitoring | Sentry + Axiom | Datadog (eat your own dog food someday) |
| CI/CD | GitHub Actions | GitHub Actions |
| Secrets | Railway env vars | AWS Secrets Manager |

---

## 7. UX Architecture

### 7.1 Information Architecture

```
flowlens.com (public)
├── / (landing page + free scan)
├── /report/:id (public scan report)
├── /login
├── /signup
│
├── /dashboard (authenticated)
│   ├── / (all projects overview)
│   │
│   ├── /project/:id
│   │   ├── / (project home — health score, today's changes, active bugs)
│   │   ├── /trends (time-series charts — health, perf, bugs over time)
│   │   ├── /map (interactive flow map / site graph)
│   │   ├── /bugs (bug tracker — filterable list)
│   │   │   └── /:bugId (bug detail — screenshot, repro, timeline)
│   │   ├── /history (crawl history — every crawl, diff viewer)
│   │   │   └── /:crawlId (single crawl report)
│   │   └── /settings (URL, auth, schedule, notifications)
│   │
│   ├── /integrations (Slack, Jira, CI/CD setup)
│   ├── /team (team members, invites)
│   └── /settings (account, billing, preferences)
```

### 7.2 Navigation Design

```
┌──────────────────────────────────────────────────────┐
│  ┌──────┐                                            │
│  │ Logo │  myapp.com ▾     [? Help]  [R. Tammewar ▾] │
│  └──────┘                                            │
├──────────┬───────────────────────────────────────────┤
│          │                                            │
│ Overview │                                            │
│ Trends   │          MAIN CONTENT AREA                 │
│ Flow Map │                                            │
│ Bugs     │                                            │
│ History  │                                            │
│          │                                            │
│ ──────── │                                            │
│ Settings │                                            │
│          │                                            │
└──────────┴───────────────────────────────────────────┘
```

- Top bar: project switcher (dropdown), user menu
- Left sidebar: navigation within a project. Collapsible.
- Main content: full width, card-based layout
- No right sidebar. Content is never cramped.

### 7.3 Key UX Flows

**Flow 1: First-time user free scan**
```
Landing page → Paste URL → Watch agent (live feed, 30s) →
See health score appear → See bugs populate one by one →
Full report (shareable URL) → CTA: "Get this every morning" →
Signup → Onboarding wizard (4 steps) → First full crawl starts
```

**Flow 2: Morning briefing → investigate bug**
```
Email/Slack briefing arrives → Click "View Full Report" →
Dashboard opens to today's crawl diff → Click on a P1 bug →
Bug detail: screenshot with annotation, repro steps, console errors →
Click "Create Jira Ticket" → Ticket created with all evidence →
Back to bug list → Snooze a P3 bug → Done. 3 minutes total.
```

**Flow 3: Check site health trend**
```
Dashboard home → Click "Trends" in sidebar →
Health score line chart (30 days) → Hover to see daily scores →
Notice a dip on Feb 15 → See deploy marker on that date →
Click deploy marker → See which bugs appeared after that deploy →
Switch to "Performance" tab → See /checkout load time spiking →
Expand /checkout row → See load time history, identify when it started
```

### 7.4 Component Design Language

**Bug Card (the most-seen component)**
```
┌──────────────────────────────────────────────┐
│  ● P1                                    2d  │
│                                              │
│  Checkout "Place Order" button unresponsive  │
│  /checkout · Mobile (375x812)                │
│                                              │
│  ┌──────────────────────────────────┐        │
│  │  [screenshot thumbnail]          │        │
│  └──────────────────────────────────┘        │
│                                              │
│  [View Details]  [Create Ticket]  [Snooze]   │
└──────────────────────────────────────────────┘
```

- Severity dot (color-coded) + age badge ("2d", "new", "14d")
- Title is human-readable (generated by LLM, not technical)
- Location context: page + viewport
- Screenshot thumbnail (expandable)
- Inline action buttons — no modals for common actions

**Health Score Widget**
```
┌─────────────────────────┐
│      78 / 100           │
│       ↑ 3               │
│                         │
│  ╭──╮                   │
│  │  ╰──╮    ╭──╮       │
│  │     ╰────╯  ╰──     │
│  30-day trend           │
└─────────────────────────┘
```

- Large score number, dominant
- Delta arrow (up/down + magnitude)
- Sparkline showing 30-day trend
- Green if improving, red if declining, gray if stable

---

## 8. Deployment Architecture

### MVP Deployment (Railway / Fly.io)

```
┌──────────────────────────────────────────────┐
│                  Railway                       │
│                                                │
│  ┌──────────┐  ┌──────────┐  ┌────────────┐  │
│  │ Frontend │  │ API      │  │ Agent      │  │
│  │ (Next.js)│  │ (FastAPI)│  │ Worker     │  │
│  │          │  │          │  │ (Temporal) │  │
│  └──────────┘  └──────────┘  └────────────┘  │
│                                                │
│  ┌──────────┐  ┌──────────┐                   │
│  │ Postgres │  │  Redis   │                   │
│  │ +Timescale│ │          │                   │
│  └──────────┘  └──────────┘                   │
│                                                │
│  ┌──────────┐                                  │
│  │ Temporal │                                  │
│  │ Server   │                                  │
│  └──────────┘                                  │
└──────────────────────────────────────────────┘

External:
  - AWS S3 (screenshots)
  - Clerk (auth)
  - SendGrid (email)
  - Cloudflare (CDN + DNS)
```

### Production Deployment (AWS)

```
┌──────────────────────────────────────────────────────────┐
│                        AWS                                 │
│                                                            │
│  ┌─────────────┐                                          │
│  │ CloudFront  │ ← CDN for frontend + screenshots         │
│  └──────┬──────┘                                          │
│         │                                                  │
│  ┌──────▼──────┐  ┌──────────────────────────────────┐   │
│  │   ALB       │  │  ECS Fargate                      │   │
│  │  (Load Bal) │──│  ┌──────────┐  ┌──────────────┐  │   │
│  └─────────────┘  │  │ API      │  │ Agent Workers │  │   │
│                   │  │ (3 tasks)│  │ (auto-scaled) │  │   │
│                   │  └──────────┘  └──────────────┘  │   │
│                   │  ┌──────────────────────────┐    │   │
│                   │  │ Temporal Workers          │    │   │
│                   │  │ (analysis + notification) │    │   │
│                   │  └──────────────────────────┘    │   │
│                   └──────────────────────────────────┘   │
│                                                            │
│  ┌──────────────┐  ┌──────────┐  ┌──────────────┐        │
│  │ RDS Postgres │  │ ElastiC. │  │  S3           │        │
│  │ + TimescaleDB│  │ (Redis)  │  │ (screenshots) │        │
│  │ Multi-AZ     │  │          │  │               │        │
│  └──────────────┘  └──────────┘  └──────────────┘        │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**Scaling considerations:**
- Agent workers are the main scaling bottleneck. Each crawl needs a browser container.
- Auto-scale agent workers based on queue depth (more sites = more workers)
- 2 AM crawl window creates bursty load. Pre-warm workers before the window.
- Each agent container needs 512MB-1GB RAM + 1 vCPU
- At 1,000 customers crawling daily: ~100-200 concurrent containers during peak window

---

## 9. Security Model

### Multi-tenancy Isolation

- **Database:** All tables have `project_id` column. Row-level security (RLS) enforced at the ORM level. No cross-tenant data leakage.
- **Agent:** Each crawl runs in an isolated Docker container. Containers are destroyed after crawl completes. No shared state between tenants.
- **Screenshots/files:** S3 paths are namespaced by project: `s3://flowlens/projects/{project_id}/crawls/{crawl_id}/...`
- **API:** JWT-based auth (Clerk). All endpoints verify project ownership.

### Credential Storage

Client website credentials (for auth flow testing) are sensitive:
- Encrypted at rest using AES-256 with per-project keys
- Keys stored in AWS Secrets Manager (or Railway env vars for MVP)
- Credentials are injected into agent containers at runtime, never stored in DB in plaintext
- Decrypted only inside the agent container, used for the crawl, then container is destroyed

### Agent Sandboxing

The browser agent visits untrusted websites. It must be sandboxed:
- Agent runs in a Docker container with no network access to internal services (only outbound to target site + LLM APIs)
- Filesystem is read-only except for temp screenshot storage
- Container is destroyed after each crawl
- Resource limits: CPU cap, memory cap, timeout per crawl (30 minutes max)

---

## 10. Scalability Strategy

### Phase 1: MVP (0-500 customers)

- Single Railway deployment
- PostgreSQL + TimescaleDB on managed Railway DB
- Agent workers share a pool of 5-10 containers
- Crawls staggered across the night to avoid all running at once
- Cost: ~$200-500/month infrastructure

### Phase 2: Growth (500-5,000 customers)

- Migrate to AWS ECS Fargate
- RDS PostgreSQL Multi-AZ for high availability
- Auto-scaling agent worker pool (scales with queue depth)
- S3 + CloudFront for screenshot delivery
- Dedicated Temporal cluster
- Cost: ~$2,000-5,000/month infrastructure

### Phase 3: Scale (5,000+ customers)

- Kubernetes (EKS) for complex orchestration
- Read replicas for PostgreSQL (dashboard reads vs write-heavy crawl results)
- TimescaleDB compression for historical data (90-95% storage reduction)
- Regional deployment (US + EU) for data residency compliance
- Dedicated agent pools per customer tier (Enterprise gets priority)
- Cost: scales linearly with customers

### Key Bottleneck: LLM Costs

At scale, LLM API calls are the largest variable cost:
- ~50 LLM calls per crawl (Navigator calls per page)
- At $0.003 per call (Claude Haiku): ~$0.15 per crawl
- 1,000 customers × daily crawls = $150/day = $4,500/month
- Mitigation: cache Navigator decisions for unchanged pages, use lighter models for simple pages, only use vision for pages that look different from their fingerprint
